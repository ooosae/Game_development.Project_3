# DOD

Ознакомление с принципами Data-Oriented Design’а и паттерном Entity Component System


## Contents

1. [Chapter I](#chapter-i) \
   1.1. [Introduction](#introduction)
2. [Chapter II](#chapter-ii) \
   2.1. [Information](#information) \
   2.2. [Data-Oriented Design](#data-oriented-design) \
   2.3. [Преимущества Data-Oriented Design](#преимущества-data-oriented-design) \
   2.4. [Отличия DOD от ООП](#отличия-dod-от-ооп) \
   2.5. [Паттерн ECS](#паттерн-ecs) \
   2.6. [ECS фреймворки в Unity](#ecs-фреймворки-в-unity)
3. [Chapter III](#chapter-iii) \
   3.1. [Part 1. Больше рефактора](#part-1-больше-рефактора)


## Chapter I

## Introduction

В данном проекте тебе предстоит познакомиться с принципом Data-Oriented Design’а и паттерном Entity Component System, а также переписать код из проекта 2 с использованием одного из предложенных ECS фреймворков в DOD подходе.


## Chapter II

## Information

Data-Oriented Design (DOD) - это подход к проектированию программ, основанный на более эффективном использовании кэша процессора, используемый при разработке видеоигр заместо привычного ООП. 

### Data-Oriented Design

Код, написанный в классическом стиле ООП, вынуждает разработчиков использовать шаблоны, в которых основное внимание уделяется абстракциям и наследованию. Хотя эти концепции имеют свое место в программировании, они могут стать серьезным препятствием, когда дело доходит до написания эффективного и оптимизируемого кода.

DOD позволяет, в первую очередь, фокусироваться на данных, на том, как организованна их обработка и хранение. Основная причина мощи концепции DOD заключается в том, что она очень хорошо работает с большими группами объектов. ООП, по определению, работает с одним объектом, что не очень характерно для игр, где, как правило, в один момент времени необходимо просчитывать логику нескольких NPC, частиц, пуль, предметов, работающих по одинаковому или схожему принципу.

### Преимущества Data-Oriented Design

- ****Параллельность.**** В DOD у нас есть некоторый массив одинаковых данных и функция, которая их обрабатывает, что сильно упрощает процесс распараллеливания вычислений, избавляя от опасности одновременного доступа к данным из нескольких потоков;
- ****Использование кеша.**** DOD позволяет очень эффективно использовать кеш команд, потому что в нём постоянно выполняется один и тот же код. Кроме того, расположив данные большими смежными блоками, их можно обрабатывать последовательно, добившись почти идеального использования кеша данных;
- ****Модульность.**** Код в DOD представляет из себя маленькие функции с очень малым количеством зависимостей с другими частями кода, что упрощает понимание, замену и обновление кода, увеличивается расширяемость;
- ****Тестирование.**** Для маленьких функций обработчиков данных просто писать юнит-тесты: создаём некие входящие данные, вызываем преобразующую их функцию, и проверяем, соответствуют ли выходные данные ожидаемым.

### Отличия DOD от ООП

| ООП | DOD |
| --- | --- |
| Класс представляет из себя набор данных и функций, которые эти данные обрабатывают | Данные и логика, которая их обрабатывает существуют отдельно независимые друг от друга |
| Данные рассматриваются как элементы состояния объекта | Данные рассматриваются как информация, которую необходимо обработать |
| Абстрагирование, наследование, инкапсуляция | Разбиение объектов на отдельные компоненты - данные, которые предполагается обрабатывать вместе |
| Объект - экземпляр класса | Объект - композиция компонентов, содержащих данные, описывающие его свойства |
| «Массив структур» - все данные каждого объекта находятся в общем потоке данных вне зависимости от того используются они или нет | «Структура массивов» - одинаковые данные организуются в отдельный массив. В потоке данных находятся только те данные, с которыми ведется работа |
| Полиморфизм, виртуальные вызовы | Отсутствие скрытого поведения |
| Нацеливание на вертикальные связи, сложность выделения объектов и иерархии наследования для игр | Нацеливание на горизонтальные связи |

### Паттерн ECS

Entity Component System (ECS) - архитектурный паттерн, который позволяет реализовать принципы Data-Oriented Design’а на объектно-ориентированных языках программирования. ECS базируется на следующих 3 определениях: entity (сущность), component (компонент) и system (система).

- Сущность (Entity) - это любой объект в игре. Например, это может быть юнит игрока, кнопка в интерфейсе, событие с данными от одной системы к другой и т.п. Сущности сами по себе не имеют свойств и выступают контейнером для компонентов. По аналогии с юнити - это  `GameObject`. Обычно представляет из себя индекс, указывающий на данные в массиве, которые характеризуют именно эту сущность;
- Компоненты (Components)–  это блоки данных, определяющие всевозможные свойства любых игровых объектов или событий. В идеале они являются объектами с простой структурой данных. Могут добавляться и удаляться с сущности в течении её жизненного цикла;
    - Компоненты - структуры с данными, которые продолжительное время связаны с сущностью. Например, `PositionComponent`, содержащий данные о положении сущности в пространстве;
        
        ```csharp
        public struct PositionComponent
        {
        		public Vector3 Position;
        }
        ```
        
    - События - структуры с данными (или без), которые связаны с сущностью в течении одного кадра. Например, `HitEvent`, говорящий о том, что в этом кадре в сущность было совершено попадание;
        
        ```csharp
        public struct HitEvent
        {
        		public int Damage;
        }
        ```
        
    - Тэги - структуры без данных, которые продолжительное время связаны с сущностью. Например, `PlayerTag`, указывающий на то, что сущность является игроком, служит меткой для отделения игрока от других сущностей при фильтрации;
        
        ```csharp
        public struct PlayerTag { }
        ```
        
- Система (System) – класс с определенными методами над определенными компонентами. Системы не содержат никаких локальных данных или ссылок на сущности или компоненты, они служат только для обработки массивов отфильтрованных по условиям сущностей и компонентов, висящих на этих сущностях. В качестве условий для фильтрации сущностей выступают компоненты, которые должны либо содержаться, либо не содержаться сущностью. 
Например, `var filter1 = GetEntities().With<PositionComponent, HitEvent>()` могло бы вернуть массив всех сущностей, которые содержат `PositionComponent` и `HitEvent`, то есть всех находящихся в пространстве, в которых в этом кадре было совершено попадание.
Или, например, `var filter2 = GetEntities().With<PositionComponent>().Without<PlayerTag>()` могло бы вернуть массив всех сущностей, которые содержат `PositionComponent` и не содержат `PlayerTag`, то есть всех находящихся в пространстве не игроков.
Важно учитывать, что системы отрабатывают последовательно, одна за другой, поэтому необходимо следить за порядком их вызова.

### ECS фреймворки в Unity

- **LeoECSLite -** легковесный C# Entity Component System фреймворк, содержащий необходимый минимум и полностью абстрагированный от Unity, поэтому для удобной интеграции могут понадобиться дополнительные расширения;
- **Morpeh -** ECS фреймворк, который более ориентирован на интеграцию с Unity. Для использования некоторых удобств интеграции (создание сущностей, добавление компонентов через эдитор) требуется платный ассет - Odin Inspector.
- **Entities (Unity DOTS) -** ECS фреймворк от Unity, до сих пор находится на этапе разработки и часто серьезно перерабатывается. Наиболее актуальная версия доступна только для Unity 2022.2+.


## Chapter III

### Part 1. Больше рефактора

Требуется переписать код из проекта Game Design с использованием одного из предложенных ECS фреймворков в DOD подходе. Обязательно требуется переписать только игровую логику, ui можно оставить в ООП подходе.

- Игровой объект игрока должен представлять из себя ECS сущность
- NPC под управлением ИИ должны представлять из себя ECS сущности
- Все игровые объекты, с которыми подразумевается взаимодействие, должны представлять из себя ECS сущности
- Все runtime-данные из `MonoBehaviour` должны быть перенесены в ECS компоненты
- В `MonoBehaviour` допускаются только `SerializeField` readonly-поля, использующиеся для конфигурации объектов из эдитора.
- Разбиение данных по компонентам должно быть логически обоснованно: нельзя хранить в одном компоненте данные, которые всегда или в большем количестве случаев обрабатываются раздельно, но и не стоит дробить вплоть до того, что все компоненты будут с единственным полем. Стоит избегать дублирования данных в компонентах. Если такая потребность возникает, лучше вынести дублирующиеся данные в отдельных компонент. При распределении данных стоит ориентировать на алгоритм:
    1. Если данные используются реализации для одной механики и обрабатываются вместе, то их стоит объединить в один компонент
    2. Если есть сущности или системы, для которых необходимы только некоторые данные из этих данных, то стоит разделить компонент на два новых
- Компоненты должны представлять из себя простые структуры данных, не должны содержать никакой логики их обработки. Допускаются только различного рода «хелперы», предусмотренные фреймворком (например, метод очистки компонента или восстановления у полей значения по умолчанию)
- Вся логика из методов `Update()` в `MonoBehaviour` должна быть перенесена в ECS системы.
- ECS системы не должны содержать никакого состояние. Допускается хранение некоторых данных в полях класса, таких как кэши пулов, фильтров, вспомогательные классы-сервисы, или константы
- Системы, преимущественно, должны содержать не более одного внешнего цикла перебора фильтра. На количество вложенных циклов ограничений нет.
- При необходимости выполнять одинаковую или сильно схожую логику над разными фильтрами необходимо выделять отдельную систему для каждого фильтра, а общая логика должна быть вынесена в классы-сервисы (статические или пробрасываемые в системы в конструкторе или при инициализации).
    - Класс-сервис должен представлять из себя исключительно набор общих методов для обработки данных
    - Системы перебирают фильтр и вызывают методы сервисов, передавая туда данные из компонентов
- Для связи Unity и ECS мира (физика, UI, различные загрузчики сцен/уровней и так далее):
    - В направлении **Unity → ECS**. Необходимо реализовать `MonoBehaviour` с обработчиками событий Unity (`OnCollisionEnter()`, `OnCollisionStay()` и т.д. для физики, `OnButtonClick()` и т.д. для UI). Эти обработчики должны создавать соотвествующий ECS эвент, содержащий данные о событии. Эвент должен создаваться в отдельном от остальных сущностей ECS мире (мире для событий)
    - В направлении **ECS → Unity**. Необходимо пробрасывать в ECS систему `MonoBehaviour` через компонент и вызывать его методы

💡 [Нажми сюда](https://forms.yandex.ru/cloud/647072d102848f176baa0732/), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.
